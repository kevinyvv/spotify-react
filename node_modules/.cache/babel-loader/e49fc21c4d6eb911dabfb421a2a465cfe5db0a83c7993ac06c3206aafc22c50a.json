{"ast":null,"code":"'use client';\n\nimport { createContext, Component, isValidElement, createElement, useContext, useState, useMemo, forwardRef } from 'react';\nconst ErrorBoundaryContext = createContext(null);\nconst initialState = {\n  didCatch: false,\n  error: null\n};\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      didCatch: true,\n      error\n    };\n  }\n  resetErrorBoundary() {\n    const {\n      error\n    } = this.state;\n    if (error !== null) {\n      var _this$props$onReset, _this$props;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n        args,\n        reason: \"imperative-api\"\n      });\n      this.setState(initialState);\n    }\n  }\n  componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      didCatch\n    } = this.state;\n    const {\n      resetKeys\n    } = this.props;\n\n    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onReset2, _this$props3;\n      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\"\n      });\n      this.setState(initialState);\n    }\n  }\n  render() {\n    const {\n      children,\n      fallbackRender,\n      FallbackComponent,\n      fallback\n    } = this.props;\n    const {\n      didCatch,\n      error\n    } = this.state;\n    let childToRender = children;\n    if (didCatch) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n      if (isValidElement(fallback)) {\n        childToRender = fallback;\n      } else if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else {\n        {\n          console.error(\"react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop\");\n        }\n        throw error;\n      }\n    }\n    return createElement(ErrorBoundaryContext.Provider, {\n      value: {\n        didCatch,\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      }\n    }, childToRender);\n  }\n}\nfunction hasArrayChanged() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));\n}\nfunction assertErrorBoundaryContext(value) {\n  if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n  return true;\n}\nfunction useErrorBoundary() {\n  const context = useContext(ErrorBoundaryContext);\n  assertErrorBoundaryContext(context);\n  const [state, setState] = useState({\n    error: null,\n    hasError: false\n  });\n  const memoized = useMemo(() => ({\n    resetBoundary: () => {\n      context === null || context === void 0 ? void 0 : context.resetErrorBoundary();\n      setState({\n        error: null,\n        hasError: false\n      });\n    },\n    showBoundary: error => setState({\n      error,\n      hasError: true\n    })\n  }), [context === null || context === void 0 ? void 0 : context.resetErrorBoundary]);\n  if (state.hasError) {\n    throw state.error;\n  }\n  return memoized;\n}\nfunction withErrorBoundary(component, errorBoundaryProps) {\n  const Wrapped = forwardRef((props, ref) => createElement(ErrorBoundary, errorBoundaryProps, createElement(component, {\n    ...props,\n    ref\n  })));\n\n  // Format for display in DevTools\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n  return Wrapped;\n}\nexport { ErrorBoundary, ErrorBoundaryContext, useErrorBoundary, withErrorBoundary };","map":{"version":3,"names":["createContext","Component","isValidElement","createElement","useContext","useState","useMemo","forwardRef","ErrorBoundaryContext","initialState","didCatch","error","ErrorBoundary","constructor","props","resetErrorBoundary","bind","state","getDerivedStateFromError","_this$props$onReset","_this$props","_len","arguments","length","args","Array","_key","onReset","call","reason","setState","componentDidCatch","info","_this$props$onError","_this$props2","onError","componentDidUpdate","prevProps","prevState","resetKeys","hasArrayChanged","_this$props$onReset2","_this$props3","next","prev","render","children","fallbackRender","FallbackComponent","fallback","childToRender","console","Provider","value","a","undefined","b","some","item","index","Object","is","assertErrorBoundaryContext","Error","useErrorBoundary","context","hasError","memoized","resetBoundary","showBoundary","withErrorBoundary","component","errorBoundaryProps","Wrapped","ref","name","displayName","concat"],"sources":["/Users/kevin/spotify-react/node_modules/react-error-boundary/dist/react-error-boundary.development.esm.js"],"sourcesContent":["'use client';\nimport { createContext, Component, isValidElement, createElement, useContext, useState, useMemo, forwardRef } from 'react';\n\nconst ErrorBoundaryContext = createContext(null);\n\nconst initialState = {\n  didCatch: false,\n  error: null\n};\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      didCatch: true,\n      error\n    };\n  }\n  resetErrorBoundary() {\n    const {\n      error\n    } = this.state;\n    if (error !== null) {\n      var _this$props$onReset, _this$props;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n        args,\n        reason: \"imperative-api\"\n      });\n      this.setState(initialState);\n    }\n  }\n  componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      didCatch\n    } = this.state;\n    const {\n      resetKeys\n    } = this.props;\n\n    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onReset2, _this$props3;\n      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\"\n      });\n      this.setState(initialState);\n    }\n  }\n  render() {\n    const {\n      children,\n      fallbackRender,\n      FallbackComponent,\n      fallback\n    } = this.props;\n    const {\n      didCatch,\n      error\n    } = this.state;\n    let childToRender = children;\n    if (didCatch) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n      if (isValidElement(fallback)) {\n        childToRender = fallback;\n      } else if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else {\n        {\n          console.error(\"react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop\");\n        }\n        throw error;\n      }\n    }\n    return createElement(ErrorBoundaryContext.Provider, {\n      value: {\n        didCatch,\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      }\n    }, childToRender);\n  }\n}\nfunction hasArrayChanged() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));\n}\n\nfunction assertErrorBoundaryContext(value) {\n  if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n  return true;\n}\n\nfunction useErrorBoundary() {\n  const context = useContext(ErrorBoundaryContext);\n  assertErrorBoundaryContext(context);\n  const [state, setState] = useState({\n    error: null,\n    hasError: false\n  });\n  const memoized = useMemo(() => ({\n    resetBoundary: () => {\n      context === null || context === void 0 ? void 0 : context.resetErrorBoundary();\n      setState({\n        error: null,\n        hasError: false\n      });\n    },\n    showBoundary: error => setState({\n      error,\n      hasError: true\n    })\n  }), [context === null || context === void 0 ? void 0 : context.resetErrorBoundary]);\n  if (state.hasError) {\n    throw state.error;\n  }\n  return memoized;\n}\n\nfunction withErrorBoundary(component, errorBoundaryProps) {\n  const Wrapped = forwardRef((props, ref) => createElement(ErrorBoundary, errorBoundaryProps, createElement(component, {\n    ...props,\n    ref\n  })));\n\n  // Format for display in DevTools\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n  return Wrapped;\n}\n\nexport { ErrorBoundary, ErrorBoundaryContext, useErrorBoundary, withErrorBoundary };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}